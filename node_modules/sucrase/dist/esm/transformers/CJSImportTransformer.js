


import {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from "../parser/tokenizer";
import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";


import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are transforming to commonjs.
 */
export default class CJSImportTransformer extends Transformer {
   __init() {this.hadExport = false}
   __init2() {this.hadNamedExport = false}
   __init3() {this.hadDefaultExport = false}
  

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     enableLegacyBabel5ModuleInterop,
     enableLegacyTypeScriptModuleInterop,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     preserveDynamicImport,
     keepUnusedImports,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;this.keepUnusedImports = keepUnusedImports;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;
    this.declarationInfo = isTypeScriptTransformEnabled
      ? getDeclarationInfo(tokens)
      : EMPTY_DECLARATION_INFO;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }

  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(tt._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(tt.name, tt.postIncDec)) {
      // Fall through to normal identifier matching if this doesn't apply.
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(tt.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(tt.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(tt.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else {
      // Otherwise, switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      if (this.preserveDynamicImport) {
        // Bail out, only making progress for this one token.
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop
        ? ""
        : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }

    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(tt.semi)) {
      this.tokens.removeToken();
    }
  }

  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
   removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      this.removeRemainingImport();
      return true;
    }

    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {
      // We have a default import or namespace import, so there must be some
      // non-type import.
      this.removeRemainingImport();
      return false;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      return false;
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    while (!this.tokens.matches1(tt.string)) {
      // Check if any named imports are of the form "foo" or "foo as bar", with
      // no leading "type".
      if (
        (!foundNonTypeImport && this.tokens.matches1(tt.braceL)) ||
        this.tokens.matches1(tt.comma)
      ) {
        this.tokens.removeToken();
        if (!this.tokens.matches1(tt.braceR)) {
          foundAnyNamedImport = true;
        }
        if (
          this.tokens.matches2(tt.name, tt.comma) ||
          this.tokens.matches2(tt.name, tt.braceR) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)
        ) {
          foundNonTypeImport = true;
        }
      }
      this.tokens.removeToken();
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   removeRemainingImport() {
    while (!this.tokens.matches1(tt.string)) {
      this.tokens.removeToken();
    }
  }

   processIdentifier() {
    const token = this.tokens.currentToken();
    if (token.shadowsGlobal) {
      return false;
    }

    if (token.identifierRole === IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }

    if (token.identifierRole !== IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(token),
    );
    if (!replacement) {
      return false;
    }
    // Tolerate any number of closing parens while looking for an opening paren
    // that indicates a function call.
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (
      possibleOpenParenIndex < this.tokens.tokens.length &&
      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR
    ) {
      possibleOpenParenIndex++;
    }
    // Avoid treating imported functions as methods of their `exports` object
    // by using `(0, f)` when the identifier is in a paren expression. Else
    // use `Function.prototype.call` when the identifier is a guaranteed
    // function call. When using `call`, pass undefined as the context.
    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {
      if (
        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&
        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new
      ) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        // Remove the old paren.
        this.tokens.removeToken();
        // Balance out the new paren.
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(tt.parenR);
      } else {
        // See here: http://2ality.com/2015/12/references.html
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }

  processObjectShorthand() {
    const identifier = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier}: ${replacement}`);
    return true;
  }

  processExport() {
    if (
      this.tokens.matches2(tt._export, tt._enum) ||
      this.tokens.matches3(tt._export, tt._const, tt._enum)
    ) {
      this.hadNamedExport = true;
      // Let the TypeScript transform handle it.
      return false;
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {
        this.hadDefaultExport = true;
        // Flow export default enums need some special handling, so handle them
        // in that tranform rather than this one.
        return false;
      }
      this.processExportDefault();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.braceL)) {
      this.processExportBindings();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    this.hadNamedExport = true;
    if (
      this.tokens.matches2(tt._export, tt._var) ||
      this.tokens.matches2(tt._export, tt._let) ||
      this.tokens.matches2(tt._export, tt._const)
    ) {
      this.processExportVar();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt._function) ||
      // export async function
      this.tokens.matches3(tt._export, tt.name, tt._function)
    ) {
      this.processExportFunction();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt._class) ||
      this.tokens.matches3(tt._export, tt._abstract, tt._class) ||
      this.tokens.matches2(tt._export, tt.at)
    ) {
      this.processExportClass();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.star)) {
      this.processExportStar();
      return true;
    } else {
      throw new Error("Unrecognized export syntax.");
    }
  }

   processAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,
    // with `b` as the identifier, so nothing needs to be done in that case.
    if (identifierToken.isType || identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {
      return false;
    }
    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {
      // Declarations don't need an extra assignment. This doesn't avoid the
      // assignment for comma-separated declarations, but it's still correct
      // since the assignment is just redundant.
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }

  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
   processComplexAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
   processPreIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    // Ignore things like ++a.b and ++a[b] and ++a().b.
    if (
      index + 2 < this.tokens.tokens.length &&
      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||
        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||
        this.tokens.matches1AtIndex(index + 2, tt.parenL))
    ) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
   processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    // We might also replace the identifier with something like exports.x, so
    // do that replacement here as well.
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }

   processExportDefault() {
    let exportedRuntimeValue = true;
    if (
      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||
      // export default async function
      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&
        this.tokens.matchesContextualAtIndex(
          this.tokens.currentIndex() + 2,
          ContextualKeyword._async,
        ))
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      // Named function export case: change it to a top-level function
      // declaration followed by exports statement.
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (
      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||
      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) ||
      this.tokens.matches3(tt._export, tt._default, tt.at)
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(tt._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
      // After this point, this is a plain "export default E" statement.
    } else if (
      shouldElideDefaultExport(
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      // We need to assign E to a variable. Change "export default E" to
      // "let _default; expor  A;¸r§A;¸r∏r ¿ÎLAçD$ˇHcœ;¯s7Hi…®   Hçå1ò  Hçô®   A∏®   Hã”Ë-  ãÜ‡	  É«ÉËHãÀ;¯rÿÉÜ‡	  ˇ3¿Hã\$@Hãl$HHãt$PHã|$XHÉƒ A^A]A\√ÃÃÃÃÃÃHâ\$E3…Ñ“Lã¡Öû   ãÅ(  EçQ®tD8â%  u	DÑë‰	  tAπ   AÑ¬tAÉ…0®txÄπ%   u	ˆÅ‰	  tfE3€D9ô‡	  v0Hçô®  HãÅ`  äAàî§  É$ E⁄HÅ√®   D;ô‡	  r◊ãâ‡	  A”‚A¡‚AÅÍ   AÉ E ÎHãÅ`  ãÄ†  IãÄ`  Dâà†  É$ Hã\$√ÃÃÃÃÃÃÃÃÃ@SHÉÏ E3¿≤HãŸË)¸ˇˇLçD$8≤HãÀËö¸ˇˇD∑D$8≤fAÅ» HãÀË¸ˇˇfA∏ ≤HãÀËı˚ˇˇE3¿≤HãÀËË˚ˇˇfA∏ ≤HãÀËŸ˚ˇˇfA∏ 0≤HãÀË ˚ˇˇfA∏ ≤HãÀËª˚ˇˇE3¿≤HãÀËÆ˚ˇˇfA∏ ê3“HãÀHÉƒ [Èö˚ˇˇÃÃÃÃÃÃHâ\$UVWATAUAVAWHÉÏ0HçôX  Hã˘@äÚHãÀˇ"  3ÌHãÀä–àá`  @àØê  ˇ  9Ø‰	  u@:ıt@8Ø%  t9Ø(  t≥Î@ä›Î	9Ø(  ï√Hãá`  â®  	,$Hãá`  «Ä      Ä	,$HãœËÔˇˇHãœËæÛˇˇHãœË‚˘ˇˇÅè    Hãá`  ãè  âàÄ  	,$@äÕDã’Lã˝LãÂHâ¨$à   àL$p9Ø‡	  DãÕÜ˝   Däd$pI«∆X˘ˇˇDãÌAª   HçØ®  L+˜AçCÏÉ¯É√   ãE ç4 D;÷suMç.AäÃIã«H—Ë¿·I¿∂î8¿  ∏   ”ÍAãÕ”‡É‚”‚˜–Aã A#¡Dã —ÈD»É·Iã«H¡ËI¿∂î8∞  ∏   ”‡#–”˙Ñ“tAçK∫   ”‚ã¬˜–D#»D çFˇD;–tçF˛D;–uAãÀ∫   ”‚ã¬˜–D#»D AÉ√AÉ≈HÅ≈®   AçCÏ;á‡	  Ç0ˇˇˇLã§$à   äL$p3Ì∏   *¡ä»àD$pHãá`  Eâå Ä  	,$IÉƒAÉ¬IÉ«AÅ˙   Lâ§$à   Ç≥˛ˇˇE3¿≤HãœËO˘ˇˇ3“HãœË)¸ˇˇfA∏ ≤HãœË6˘ˇˇ@:›uHãœËÌ¸ˇˇHãá`  ãÄ   âÑ$Ä   ã»Hãá`  É…âå$Ä   âà   	,$Hãá`  ãÄ  âÑ$Ä   ã»Hãá`  ∫È
âå$Ä   âà  	,$Hãè  3“Lçå$Ä   DçBD«Ñ$Ä     «D$    ˇò  Hã\$xHÉƒ0A_A^A]A\_^]√ÃÃÃÃÃÃÃHâ\$WHÉÏ0Hã˘Hãâ  A∏   LçL$H3“DâD$ ˇX  HçèX  ˇ˚  HçèX  ∆áê  ä–àá`  ˇÁ  Hãá`  3€âXD	$E3¿≤HãœË
¯ˇˇLçD$@≤HãœË{¯ˇˇD∑D$@≤fAÅ‡ˇÔHãœfDâD$@Ëﬂ˜ˇˇLãü`  AãÉ†  Hãá`  âò†  	$LçD$@≤HãœË1¯ˇˇfA∏ ≤HãœË¢˜ˇˇHãœË‚ÏˇˇHãœË.  Hã\$PHÉƒ0_√ÃÃÃÃÃÃÃHâ\$WHÉÏ Hã⁄3“Hã˘DçBpHãÀË2  Äø   ï¿àCZÄø¸   ï¿Ñ¿àCXtÅø   Äñò ï¿àCYHãá`  ∑ fâCHãá`  ∑@fâC
Hãá`  ãà  ∆C–ã¡¡È¡Ë$Ä·àKàCHãá`  ∑Ä  Hç>ùˇˇf=êfâCtHãÅ¿o  HâCäÅ»o  ÎHãÅ∞o  HâCäÅ∏o  àC«  HãáX  HâC0Hãá`  HâC8ãáh  âC@ãál  âCDHãá`  ãÄ  ∫‡s∆CIHãá`  ãÄ  ®t∆CHãèË  ∞âKL∑èÏ  fâKPãèÓ  âKR∑èÚ  fâKVHã\$0HÉƒ _√ÃÃÃÃÃÃHãƒHâXHâhHâp HâHWATAUAVAWHÉÏPÉ`» ÉHÃˇ3“DçjLã—«@–ZZZZ«@‘••••«@®Ä   «@¨   IãÕ«@∞  @∂ãD IÇ`  ã HÉ¬HÉÈâD,uÂ3ˇHçl$@@ÑˆtgDã} Lçt$ AÅÁ¸y  E3‰AãIãÇ`  Dâ<É$ π   ˇ∆  Lãî$Ä   Mãö`  BãD;¯uAÉƒIÉ∆E;ÂrΩÎ@2ˆÉ«HÉ≈ÉˇrîE3…BãT Iãä`  FãD0Dâ
É$ IÉ¡IÉÌu‹Lç\$P@ä∆Iã[8Iãk@IãsHIã„A_A^A]A\_√ÃÃÃÃÃÃÃÃHâ\$WHÉÏ LçD$83“Hã˘ËGıˇˇÑ¿tED∑D$83“HãœfAÅ» ÄfDâD$8ËßÙˇˇ3€Ñ¿t#LçD$83“HãœËıˇˇf∫d$8sÉ√Å˚Ë  |Ÿ2¿Hã\$0HÉƒ _√∞ÎÒÃÃÃÃÃÃÃÃÃHâ\$Hât$WHÉÏ LçD$8≤Hã˘Ë∆Ùˇˇ3€:√tLçD$8≤HãœË±ÙˇˇHãœËIˇˇˇ:√u2¿Èˆ   LçD$8≤HãœËèÙˇˇD∑D$8≤fAÅ‡ˇHãœfDâD$8ËÛÛˇˇE3¿≤HãœËÊÛˇˇLçD$8≤HãœËWÙˇˇD∑D$8≤fAÅ‡ˇÔHãœË¡ÛˇˇfA∏ ≤HãœË≤ÛˇˇfA∏Õ%≤HãœË£ÛˇˇDãü¯  «á    ·ıD;€t0AÉÎt$AÉÎtAÉÎtAÉ˚ufæ ÎfæÄÎfæ`Îfæ Îfæ‡fª D∑√≤	HãœËGÛˇˇD∑∆≤HãœË9ÛˇˇfA∏ ê3“HãœË*Ûˇˇ∞Hã\$0Hãt$@HÉƒ _√ÃÃÃÃÃÃÃÃHâ\$WHÉÏ Äπ‘   HãŸumãÅ¯  ∆Å¸  Ö¿tÉËtDÉËt,ÉËtÉËu∆Å  ∏ ·ıâÅ   ∞Èn  ∆Å   ÎÂ«Å   Äñò ∆Å  Î›«Å   Äñò ∆Å   Î Äy( uÄy) t
E3¿≤ËwÚˇˇfÉd$0 3ˇLçD$0≤HãÀË‡ÚˇˇÑ¿Ñ  äD$0¿Ë$àÉ¸  Ñ–   ˆD$0 uπ
   ˇë  É«Éˇ
r∫LçD$0≤HãÀËöÚˇˇÑ¿Ñ¬   ∑|$0f∫ÁÉ≤   Ä{( tf∫Á≤HãÀsE3¿ÎfA∏ Ë·ÒˇˇÄ{) tfA∏¿ ≤HãÀËÃÒˇˇ∑œ∏ ·ı¡ÈtâÉ   Î
«É   Äñò 9É   ufA∏ ≤HãÀËñÒˇˇfA∏®≤HãÀËáÒˇˇf¡Ô@ÄÁ@àª  È∞˛ˇˇfA∏ ≤HãÀËdÒˇˇfA∏Í≤HãÀËUÒˇˇÈç˛ˇˇ2¿Hã\$8HÉƒ _√ÃÃÃÃÃÃÃHâ\$Hât$WHÉÏ Iã¯3¿HãÒAâ A∆ D∂¬fA¡‡≤fAÅ»=ƒËÒˇˇ3€πË  ˇª  LçD$8≤HãŒËlÒˇˇˆD$8tÉ√É˚dr◊LçD$8≤HãŒËNÒˇˇÑ¿t3∑T$8∏”Mb∑ àWf¡ÈÄ·à∂ i…<  ˜È∞¡˙ã ¡È—àWHã\$0Hãt$@HÉƒ _√ÃÃÃÃÃÃÃÃÃÃÃÃÃfffêfffêfêH;…  uH¡¡f˜¡ˇˇuÛ√H¡…È	   ÃÃÃÃÃÃÃÃÃHÉÏ8Lã•  Lãñ  HÉd$  Hã—π˜   ˇ™  ÃÃÃÃÃÃÃÃfffêfffêfêH+—IÉ¯r"ˆ¡tfêä:
u,Hˇ¡Iˇ»ˆ¡uÓMã»I¡ÈuMÖ¿tä:
uHˇ¡Iˇ»uÒH3¿√¿Éÿˇ√êI¡Èt7HãH;
u[HãAH;D
uLHãAH;D
u=HãAH;D
u.HÉ¡ Iˇ…uÕIÉ‡Mã»I¡ÈtõHãH;
uHÉ¡Iˇ…uÓIÉ‡ÎÉHÉ¡HÉ¡HÉ¡HãH»H…H;¡¿Éÿˇ√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃfffêfffêfêHã¡IÉ¯rS∂“IπIØ—IÉ¯@rH˜ŸÉ·tL+¡HâH»Mã»IÉ‡?I¡Èu9Mã»IÉ‡I¡ÈtfffêêHâHÉ¡Iˇ…uÙMÖ¿t
àHˇ¡Iˇ»uˆ√fffêfffêffêIÅ˘   s0HâHâQHâQHÉ¡@HâQÿHâQ‡Iˇ…HâQËHâQHâQ¯uÿÎîffêffêH√H√QH√QHÉ¡@H√QÿH√Q‡Iˇ…H√QËH√QH√Q¯u–Ä$ ÈTˇˇˇÃÃÃÃÃÃÃÃÃÃÃÃfffêfffêfêLãŸH+—Çû  IÉ¯raˆ¡t6ˆ¡tä
Iˇ»àHˇ¡ˆ¡tfã
IÉËfâHÉ¡ˆ¡tã
IÉËâHÉ¡Mã»I¡ÈuQMã»I¡ÈtHã
HâHÉ¡Iˇ…uIÉ‡MÖ¿uIã√√fffêä
àHˇ¡Iˇ»uÛIã√.tokens.matches1(tt.bracketR)) {
        depth--;
        this.tokens.copyToken();
      } else if (
        depth === 0 &&
        !this.tokens.matches1(tt.name) &&
        !this.tokens.currentToken().isType
      ) {
        break;
      } else if (this.tokens.matches1(tt.eq)) {
        // Default values might have assignments in the RHS that we want to ignore, so skip past
        // them.
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        while (this.tokens.currentIndex() < endIndex) {
          this.rootTransformer.processToken();
        }
      } else {
        const token = this.tokens.currentToken();
        if (isDeclaration(token)) {
          const name = this.tokens.identifierName();
          let replacement = this.importProcessor.getIdentifierReplacement(name);
          if (replacement === null) {
            throw new Error(`Expected a replacement for ${name} in \`export var\` syntax.`);
          }
          if (isObjectShorthandDeclaration(token)) {
            replacement = `${name}: ${replacement}`;
          }
          this.tokens.replaceToken(replacement);
        } else {
          this.rootTransformer.processToken();
        }
      }
    }

    if (needsParens) {
      // Seek to the end of the RHS.
      const endIndex = this.tokens.currentToken().rhsEndIndex;
      if (endIndex == null) {
        throw new Error("Expected = token with an end index.");
      }
      while (this.tokens.currentIndex() < endIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(")");
    }
  }

  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
   processExportFunction() {
    this.tokens.replaceToken("");
    const name = this.processNamedFunction();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }

  /**
   * Skip past a function with a name and return that name.
   */
   processNamedFunction() {
    if (this.tokens.matches1(tt._function)) {
      this.tokens.copyToken();
    } else if (this.tokens.matches2(tt.name, tt._function)) {
      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {
        throw new Error("Expected async keyword in function export.");
      }
      this.tokens.copyToken();
      this.tokens.copyToken();
    }
    if (this.tokens.matches1(tt.star)) {
      this.tokens.copyToken();
    }
    if (!this.tokens.matches1(tt.name)) {
      throw new Error("Expected identifier for exported function name.");
    }
    const name = this.tokens.identifierName();
    this.tokens.copyToken();
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
    }
    this.tokens.copyExpectedToken(tt.parenL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(tt.parenR);
    this.rootTransformer.processPossibleTypeRange();
    this.tokens.copyExpectedToken(tt.braceL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(tt.braceR);
    return name;
  }

  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
   processExportClass() {
    this.tokens.removeInitialToken();
    this.copyDecorators();
    if (this.tokens.matches1(tt._abstract)) {
      this.tokens.removeToken();
    }
    const name = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }

  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
   processExportBindings() {
    thise r i t e ,   a l i   s t e   v n e s l i   p r a v i l n o   u p o r a b n i ak o   i m e ,   g e s l o   i n   p o t r d i l o .   e   ~e l i t e   u p o r a b i t i   d r u g o   p o t r d i l o ,   i z b e r i t e   m o ~n o s t   ª N a s t a v i t v e ´   i n   n a t o   p o i s t i t e   p o t r d i t v e n o   p o l j e   ª S a m o d e j n o   i z b e r i   p o t r d i l o   z a m e ´ .                               PAd V a aa   n a p r a v a   n i   v   s k l a d u   z   v a r n o s t n i m i   p r a v i l n i k i ,   k i   j i h   j e   n a s t a v i l   v a a  s k r b n i k   e - p o at e . 
 
 
 % 1 ! s ! 
               + P o s l a n o   i z   m o j e   n a p r a v e   s   s i s t e m o m   W i n d o w s                   PA\ N e   m o r e m o   p r i d o b i t i   ~e t o n a   z a   p r e v e r j a n j e   p r i s t n o s t i   z   e n o t n o   p r i j a v o   z a   v a a  r a u n . 
 
 % 1 ! s ! 
                                  Z g o d o v i n a   s p o r o i l    L j u d j e    S k u p i n e   i n   n a s t a v i t v e                             î4   V S _ V E R S I O N _ I N F O     ΩÔ˛     
  aJ  
  aJ?                        Ú   S t r i n g F i l e I n f o   Œ   0 4 2 4 0 4 B 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   V   F i l e D e s c r i p t i o n     S r e d s t v a   z a   A c t i v e S y n c     h $  F i l e V e r s i o n     1 0 . 0 . 1 9 0 4 1 . 1   ( W i n B u i l d . 1 6 0 1 0 1 . 0 8 0 0 )   0   I n t e r n a l N a m e   S y n c R e s   Ñ 0  L e g a l C o p y r i g h t   ©   M i c r o s o f t   C o r p o r a t i o n .   V s e   p r a v i c e   p r i d r ~a n e .   H   O r i g i n a l F i l e n a m e   S y n c R e s . d l l . m u i   n '  P r o d u c t N a m e     O p e r a c i j s k i   s i s t e m   M i c r o s o f t Æ   W i n d o w s Æ     >   P r o d u c t V e r s i o n   1 0 . 0 . 1 9 0 4 1 . 1     D    V a r F i l e I n f o     $    T r a n s l a t i o n     $∞PADDINGXXPADDINGPADDINGXXPADDING                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              