{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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░       ЪЪ  ╦       @                                   Х   ╨ ╢	м!╦Lм!This program cannot be run in DOS mode.
$       +Щ o°nUo°nUo°nUfДЩUM°nU{ВmTm°nU{ВjTb°nUo°oU"°nU{ВoTf°nU{ВnTn°nU{ВfTk°nU{В▒Un°nU{ВlTn°nURicho°nU        PE  d├ ÷й║═        П "  X   6      P[        ─         
   
           п     ┘З   `A                                   Ю┐  l   L└  h   ╟     ═  D   ▄  8!   ю  ■   П|  T                           ─q            ≤r  p                          .text   `W      X                    `.rdata  n   p       \              @  @.data   @   ░      |              @  ю.pdata  D   ═      ~              @  @.rsrc      ╟      └              @  @.reloc  ■    ю      ┼              @  B                                                                                                                                                                                                                                                                                                ллллллллллллллллH▀1├  H┴2─  H█+─  H┴├  цлллллллллллллллллллH┐Л(H█У  HЪЖc  D  H┴Z─  H┐д(цлллллллллллллH▀я┘  H┴Й  H█Ц  H┴╪┘  цлллллллллллллллллллH┐Л(H┐d$0 L█D$0H█Jk  ╧   HЪ├b  D  ┘ю└х   H▀L$0H┘и└╨   H█4k  HЪMb  D  H▀L$0H█4k  H┴e┘  HЪ.b  D  H▀L$0H█-k  H┴N┘  HЪb  D  H▀L$0H█k  H┴7┘  HЪПa  D  H┐=┘   H┴$┘  tH┐=
┘   tH┐=┘   tH┘юu H┐%И└   H┐%И└   H┐%И└   H┐%И└   H█╒U  H┐д(ИM  лллллллллH┐Л8H▀╜└  H┘юtAH▀а└  H┘иtH▀²└  Ъ7c  H┐%╖└   H▀─└  L█≥└  E3ю3рH█╫j  Ъc  H█ЬT  H┐д8И≈L  лллллллллллллллH▀дH┴PL┴@L┴H SH┐Л L█@Х[$  ▀ь┘юy▀хХ)  ▀кХ/)  ▀цH┐д [цлллллллH┴\$H┴|$UAVAWH▀ЛH┐ЛPH┐eП E▀Ь┐eЭ L█Gd  ┐eЬ L▀ЯH┐eЮ H█MПL▀й3шH█Kd  H┴]ХХн"  ▀Ь┘юx}I▀H█UЮI▀нH▀─   ЪEb  ▀Ь┘юx`H9]Юu3ЪК]H▀UПL█M8L█EХХl!  ▀Ь┘юy▀хХg(  H▀]ХК9H▀MЮA╧─   H▀]ХAВъH┴\$ рH▀E█A│┐бH▀@0ЪЕa  ▀Ь┘юy▀хХ((  ▀оХA(  H┘шtH▀кHЪб_  D  H▀MЮH┘иtH▀H▀@Ъ╖a  H┐eЮ H┐}П t!HЪt_  D  L▀EП3рH▀хHЪg_  D  H▀\$p▀гH▀|$xH┐дPA_A^]цллллллллH▀дH┴XH┴pH┴x H┴HUATAUAVAWH▀ЛH┐Л@E3ДM▀ЫM▀ХD▀РH▀ыA▀ТL┴eПL┴eЬD9eP└▄   H█UPH█Зb  ХiC  ▀Ь┘юy▀хК^D▀ePH█MПA▀тE3юХ╗5  H▀uП▀Ь┘юy	▀хХ''  К+▀]ЬH█╩b  M▀дMюH█^ХO  AэE3Д┴]ЬfD┴$^H▀]0▀оХ'  ┘Ъy▀оХХ&  ▀оХ'  ┘Ъy▀оКbH█MПM▀еM┘Ъu"E▀нH█{b  Хз   ▀Ь┘юy#▀хХ╠&  H▀uПК9M▀оD┴t$ H█▄b  ХЁ   КвH▀uПH▀кAаНH▀жE▀фХЩЪЪ▀Ь┘юy▀хХr&  ▀оХ▀&  H┘Жt HЪО]  D  L▀ф3рH▀хHЪЦ]  D  L█\$@▀гI▀[8I▀s@I▀{HI▀ЦA_A^A]A\]цллллллллллH┴\$H┴l$VWATAVAWH┐Л03ш3ЪM▀ЮL▀ЗL▀ЯH┴\$`╬@ ─H9┘▌   E3юH█|b  3рHЪц]  D  I▀H▀ХH┘иtHЪ▄]  D  I┴.H┘МuWHЪЬ\  D  ┘юu▀НК╥Х│м  ─┘юNХI▀NL█2b  !\$ E3и▀уХхЩЪЪ▀Ь┘юy▀хХg%  И²   ▀Щ┘Мy▀мКЛI▀I▀вHЪ#]  D  H▀ХH┘юuuL█D$`I▀вХУ  ▀Ь┘юy▀хХ$%  H▀\$`КXHЪf\  D  ┘юt╥П│н  ─┘юNПH▀\$`L█b  I▀NL▀к┐d$  ▀жХ4ЩЪЪ▀Ь┘ю┬hЪЪЪ▀Ч┘Жy▀нИ]ЪЪЪI┴,$▀оХч$  H┘шt(HЪB\  D  L█CЭ3рH▀хHЪ5\  D  3иХ╠$  H▀\$h▀гH▀l$pH┐д0A_A^A\_^цллллллллH┴\$WH┐Л H▀ы╧@ ─I▀ЬM┘юu╧@ ─КMH▀H;}e  u$H▀BH;xe  uH▀H▀кH▀@Ъж]  3иH┴К"H▀H;=e  uH▀BH;8e  tпI┐  ХЩ#  H▀\$0▀аH┐д _цллллллллллллллллH┴\$WH┐Л H▀ы╧@ ─I▀ЬM┘юu╧@ ─КMH▀H;Мd  u$H▀BH;Хd  uH▀H▀кH▀@ЪF]  3иH┴К"H▀H;²d  uH▀BH;≤d  tпI┐  Хm#  H▀\$0▀аH┐д _цллллллллH┴\$H┴t$H┴|$ UATAUAVAWH▀ЛH│Л─   H┐eь I▀ЫH┐eю I▀ПH┐eп L▀БL▀ИH┘рu╧W ─▀ыХ
#  И╨  H┘ЖtЙA┐  H█m`  L█EЮХпЭЪЪ▀ь┘юy▀хКсL█EПI▀мH█\`  ХЁЭЪЪ▀ь┘юxЦI▀MH█EюH┴D$(L█Щc  H█EхA╧   H┴D$ 3рH▀EЮЪJ\  =Пюu┐& H┘ЪtT]  С3шИ  E3ЖD9uх├Ф   H▀UюH█EьH┴D$(L█MЛH█EХA▀нHаАL█Я_  H┴D$ HяH▀EПH┴MЬI▀ME▀ЧЪэ[  ┘юx H▀MьH┘и└┬   HЪдY  D  H┐eь КuH▀MпH┘иtHЪ╗Y  D  H┐eп L▀EЬH█EпLEю╨   I▀M┐e8 H┴D$(H█E8H┴D$ D█JH▀EЮЪi[  ┘юx
┐}8 ┤т   █┬НШ?ВаЩЪЪЪt
▀ь┘ю┬э   AЪфD;uх┌ЪЪЪH┘ЪtJ\  С┐>H█T_  L█%_  ▀сLEхL█p_  ┐d$  I▀лХ÷ЫЪЪ▀кХd!  H▀MпH┘иtHЪДX  D  H┐eп H▀MюH┘иtHЪйX  D  H┐eю H▀MьH┘иtHЪ╟X  D  L█°$─   ▀цI▀[0I▀s@I▀{HI▀ЦA_A^A]A\]цлг   H┘Ъ└HЧЪЪH▀EюMЪBЬИ3ЧЪЪ▀хХ╟   И5ЪЪЪлллллллH┴\$UVWATAUAVAWH█l$ыH│Л╟   H▀╘u  H3дH┴EE3ЪD▀ЙL┴}гA▀ъH┴]вL▀ЯL┴}©A▀ЪL┴}оL┴}ГL┴}ЪL┴}ъH┘иu╬W ─▀нИШ   L┴}г3иХS   L┴uоI▀нI▀H▀@ЪоY  L█E╥H█D\  H█M©ХОЫЪЪ▀П┘юy▀хИ╩   H▀E╥H█MгЪ═Y  D▀Ю=  ┘▒   H┘шt,HЪfW  D  L█CЭ3рH▀хHЪYW  D  3иХу  H!}вE▀гH█ъ[  H█MвХ^ЖЪЪ▀П┘ю┬÷   H▀]вL█ы[  !|$ L▀к╨  I▀нХиВЪЪ▀П┘юxq╧Х  HЪX  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      R e s p o n s i v e S t y l e      R e s p o n s i v e C o l u m n P a d d i n g      P i c k e r L i s t V i e w I t e m      M e d i u m B r e a k P o i n t   /   L i s t V i e w I t e m S e l e c t e d P o i n t e r O v e r B o r d e r T h e m e B r u s h   3   L i s t V i e w I t e m S e l e c t e d P o i n t e r O v e r B a c k g r o u n d T h e m e B r u s h   (   L i s t V i e w I t e m S e l e c t e d F o r e g r o u n d T h e m e B r u s h   (   L i s t V i e w I t e m S e l e c t e d B a c k g r o u n d T h e m e B r u s h   +   L i s t V i e w I t e m P o i n t e r O v e r B a c k g r o u n d T h e m e B r u s h   +   L i s t V i e w I t e m P l a c e h o l d e r B a c k g r o u n d T h e m e B r u s h   0   L i s t V i e w I t e m O v e r l a y S e c o n d a r y F o r e g r o u n d T h e m e B r u s h   '   L i s t V i e w I t e m O v e r l a y F o r e g r o u n d T h e m e B r u s h   '   L i s t V i e w I t e m O v e r l a y B a c k g r o u n d T h e m e B r u s h   !   L i s t V i e w I t e m F o c u s B o r d e r T h e m e B r u s h   %   L i s t V i e w I t e m F o c u s B a c k g r o u n d T h e m e B r u s h   $   L i s t V i e w I t e m D r a g F o r e g r o u n d T h e m e B r u s h   $   L i s t V i e w I t e m D r a g B a c k g r o u n d T h e m e B r u s h      L i s t V i e w I t e m C h e c k T h e m e B r u s h   $   L i s t V i e w I t e m C h e c k S e l e c t i n g T h e m e B r u s h      L i s t V i e w I t e m C h e c k H i n t T h e m e B r u s h      L i s t V i e w H e a d e r C o n t a i n e r S t y l e   
   I c o n s S t y l e      H e a d e r S t y l e      C o m b o B o x F o r e g r o u n d T h e m e B r u s h      C o m b o B o x B o r d e r T h e m e B r u s h      C o m b o B o x B a c k g r o u n d T h e m e B r u s h   !   C o m b o B o x A r r o w F o r e g r o u n d T h e m e B r u s h      B u t t o n S e c o n d a r y S t y l e                                      X       Й  Й  │  │  ▐  ▐  ²  ²  ╔  ╔  Ё  Ё  а  а  о  о  щ  щ  ъ  ъ  С  С  ┘  ┘  П  П  &  &  9  9  Q  Q  }  }  ─  ─  q  q  ё  ё  *  *        +   +   +!  +!  "  "  "  "  F"  F"  e#  e#  m%  m%  o%  o%  q%  q%  ║%  ║%  (  (  A+  A+  e+  e+  ╡,  ╡,  ┘.  ┘.  ╩.  ╩.  3  3  ⌠5  ⌠5  а5  а5  97  97  ;  ;  ≥;  ≥;  ²;  ²;  i?  i?  ╥D  ╥D  ЩD  ЩD  FG  FG  fG  fG  H  H  tI  tI  ЁJ  ЁJ  шJ  шJ  M  M  0M  0M  АM  АM  >O  >O  RQ  RQ  |Q  |Q  ╡R  ╡R  ▓T  ▓T  дT  дT  V  V  \Y  \Y  ╦Y  ╦Y  j]  j]  b  b  |b  |b  0f  0f  k  k  Ck  Ck  Vl  Vl  nm  nm  pm  pm  ╙m  ╙m  p  p  5p  5p  Жp  Жp  r  r  Is  Is  ws  ws  t  t  сt  сt  Аt  Аt  Оt  Оt  Щt  Щt  u            x     c o n t r o l     l o c a l     v s m s│  
h MT╛╕² ▓Ы ▄╞ из	T p? ├ЫS НИЗ ╙╩З≈	yО ╥O Fыг╬п╩ЧБ й!я
"б#А$b%i&['©(р)╙■*т+Ю8 ▀,Щ-Щ.╖/²0▐1┌2В3К4ъ5┐6х7╪8╟9╓:≤;Й<│=ч>р?ф@╨A╝BпCу└ ЁD╩й лб ╣╫ ┤к ·м Пл ы╪ б╦ ╚╥ ■и Щх Фд о╝ ╡╚ ⌡╜ └╛ М╙ ж╘ ©╕ ╗╔ ▒╖ З╗ Ц╢ ╦E║с ┼ю С© эя еп ╝о ≈F─GИн рH╩р ╓IО     !          x     c o n t r o l     l o c a l     v s m s│;─ !;─ !q─ !q─ !q─	 !q─
 !4─  ─A!4─ ─D!4─  fD!4─  @B!4─   B!A─     `B!4─ ≥Ц?!r─В─▄│  0─<    ┐┐!r─В─▄│  ┐0┐  ─A┐0%┐╕   !r─В─ж│  0─<    щ┌0┴│  ─?0┼│p   !r─В─▄│  ┐0┐  ─A┐0%┐╕   !r─В─▄│  0─<    ┐0┐  ╟A┐0█│      @@        !r─В─▄│  ┐0┐  ─A┐0%┐╕   !r─В─▄│  ┐0┐  юA0┐ ┐!r─Т─ В─▄│	  0┐  PA!r─В─(┌
  0┌ЪЪЪ 0┌ЪЪЪ 0┌                0)┌p   0╠└▌    0╡└▓    0╤└0+┌0╧└0┌01┌╛    0е└▌   0ф└▓   0л└Ё    !r─В─┌  ┌┌0┌   @   @   @   @0#┌6 0$┌  pA0'┌# (┌0┼│p    0-┌   A  ─@   A  ─@0┌0X├0≤│╛   !r─В─┌  ┌0┌  ─?  ─?  ─?  ─?0$┌  ─A┴│0┼│p   0-┌                0┌0X├!r─Т─? В─┌  ┌0┌!r─В─┌  0┌ЪЪЪ 0┌ЪЪЪ 0┌             AC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAA;AAGxE;;;;;GAKG;AACU,QAAA,UAAU,GAIrB,OAAO,CAAC,QAAQ,KAAK,OAAO;IAC1B,CAAC,CAAC,eAAe;IACjB,CAAC,CAAC,OAAO,CAAC,QAAQ,KAAK,QAAQ;QAC/B,CAAC,CAAC,gBAAgB;QAClB,CAAC,CAAC,eAAe,CAAA","sourcesContent":["import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'path'\n\nimport { fileURLToPath } from 'url'\n\nimport * as actualFS from 'fs'\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nimport { lstat, readdir, readlink, realpath } from 'fs/promises'\n\nimport type { Dirent, Stats } from 'fs'\nimport { Minipass } from 'minipass'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true }\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n          ...defaultFS.promises,\n          ...(fsOption.promises || {}),\n        },\n      }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile()\n    ? IFREG\n    : s.isDirectory()\n    ? IFDIR\n    : s.isSymbolicLink()\n    ? IFLNK\n    : s.isCharacterDevice()\n    ? IFCHR\n    : s.isBlockDevice()\n    ? IFBLK\n    : s.isSocket()\n    ? IFSOCK\n    : s.isFIFO()\n    ? IFIFO\n    : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase = rootPath\n      ? this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name = this.nocase\n      ? normalizeNocase(pathPart)\n      : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath = this.#fullpath\n      ? this.#fullpath + s + pathPart\n      : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return this.isUnknown()\n      ? 'Unknown'\n      : this.isDirectory()\n      ? 'Directory'\n      : this.isFile()\n      ? 'File'\n      : this.isSymbolicLink()\n      ? 'SymbolicLink'\n      : this.isFIFO()\n      ? 'FIFO'\n      : this.isCharacterDevice()\n      ? 'CharacterDevice'\n      : this.isBlockDevice()\n      ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket()\n      ? 'Socket'\n      : 'Unknown'\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase\n      ? this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = (await this.parent.realpath())?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = (this.parent.realpathSync())?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      const c = children[p]\n      if (c) c.#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name = this.nocase\n        ? normalizeNocase(e.name)\n        : normalize(e.name)\n      if (name !== pchild!.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild!, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[]\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res)\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {}\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor'\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the file   ▀│Ь  КПH▀│0  КГH▀│  КчH▀│╟  КуH▀│Ь  Кл│ЙtH╦   +пt3+пt&+пt+пt;пtA╨╩  юК8H▀│P  К H▀│X  К▒H▀│`  К┬H▀│░  И|ЪЪЪH▀┴H  I┴@  I┴A▀бцллллллллH▀дH┴X UVWATAUAVAWH┐ЛP┐` H▀r(D▀r0A╫   3ЪE3Ъ3М@8╧т  L█Xг@   ▀B A█]L▀БL▀яu
╦  И:  ╧ ;а┤  └  ЪЧЧЪ┐Ь┤  H█ББЪЪ▀▄┌H!  HйЪАL█/f  ╩  Иа  L█°$≤   И╢  L█Qg  И╗  A▀┌   ┴└$░   И∙  A▀┌   ┐юКХA▀┌▄  iюР  КыA▀┌┬  КОг└$░   Р  Иa  A▀┌▄  К╥г└$░   ]  ИH  г└$░     И8  A▀┌   К▌3юA8┌Э  ■юК─L█├f  ╩'   И  M█ Х  И  L█Ye  ╩   ИС  A▀┌╟  ИFЪЪЪL█°$═   Из  ╧;а┤  └Ж   = ┤█   = ┐q  =	 t\= tI=  ├╦  = ├M  ╨ ;б┘═  ╩≤   E2МD;СD▀Ш┌l  L▀фI▀йХАЫЪЪ▀ЬИV  A▀┌  И╜ЧЪЪ!~╩   ф─f┴^D┬nD┴nL▀чИ/  = ┌D  = ├ы   =t8=t =┘   A▀┌╛  M█Z*█@шИК  M█ Н  ╩   Из  M█ Х  КМг└$░   @   Иа  ╧Щ;а┤╩   └╝  =┌ц   =v\= ├╠   =vJ=└╠   = Щ┘■   A┼┌(  ┴\$D┴\$HA"еD┴l$@L█\$@Жь╩   и┐АAм┴L$LИ@  L█└$░   ▀пI▀йХ╝ЬЪЪ┘ю▀Ь┘L  D;Сs© ю█hИ:  ╩   L█°$░   D;СABчИУ   =Щ└э   =Яи═Ъt=Ри═Ъt
©╩  юИЧ   E2МИн   ©  D;Вs!j4┴z83юИК   ▀FD▀H█▌  ┴D$0▀FH┴L$(L█NI▀р3и┴D$ Х┬  ▀╨c " ;йw;t0│И3 " tV+кtR+кt┐ИtI+кtE+кtA┐Иu4█yК:гFп  К1гFp   К(│И┐ " t+кt┐Иt+кt+кt+кt;кt3ЪК┴^A!l$8A┴|$4КFA▀┌Д	  ┴└$░   ┘Ъu(A;ч▀Кv© юК┘шtE└МtD▀цI▀сH▀нD▀ШХLJ  E┴|$4A┴l$8▀гH▀°$╗   H┐дPA_A^A]A\_^]ц*  ;  H  H  T  T  д  s  ┌  ▀  ▀  Л  ш  	  T  Ь  g     ╓  м  ⌡  ╢  лллллллл@SH┐Л ─╧░   H▀ыuф КфХ!-  ┐ёЮ	   3юH┐д [цллллллH┴\$H┴t$WH┐Л H▀ЯH│аx  H▀ЗЪBO  H┘ЪtL▀H▀вH▀нХ   M┘юI▀ЬuЙH█▌x  H▀\$0H▀t$8H┐д _HЪ%O  ллллллH┴\$H┴l$H┴t$ WATAUAVAWH┐Л@▀r H▀j(D▀b0H▀Ы3шH│аX  !\$pL▀ЗE3ЖЪыN  8÷т  H█▐X  ┬┤`  ┼пuЪдN  ╦  И╗  Ъ╢N  A╩ЩA;С┤©  └)  │Н └Ц   ┐Н└н   │Н  └╓   │НГЧЪ t│Ч И╚  ╦╚╙╙╙AВД▀РаН█vюD;Юt
╦ юИ8  H█▐X  Ъ5N  H█O*┬┤`  ╦@   ;ПGП┘Ж┴╥╛  t█vH▀уD█ Х H  К3рA╦─  ХG  H▀оХ95  D█4vEЖ┼≈`  H█▐X  ЪъM  И╨  A┐Эt
╩ юИ╝  ▀E ┴┤  И°  A┐Э└▓  КэA┐ЭuжH█▐X  Ъ∙M  ┬┤`  ▀E ;┤╟  tH▀о┴┤╟  Х
4  A╬   К└▀u ┐Чt=~u┐ЧpH█▐X  ЪRM  8÷░  H█▐X  ┬┤`  ┼пtFЪ=M  3рH▀оХъ9  К:H█▐X  ЪM  8÷░  H█▐X  ┬┤`  ┼пuЪM  H▀оХц<  КЪВL  A╬   ┴╥■  Иф   │ЧЩ└ё   │ЧЩ└┤   │ЧЩti│ЧРи═Ъt
╩╩  юИ≤   H┘М╦  t>D;Юr9▀ED▀E H██  L█M┴D$0H┴L$(3иM┘иH▀вu!\$ Х  КO▀E┴D$ КПA!_4A┴G8╦ юКK▀E A╬   ┴┤Д	  D┴t$pК'E▀дH▀уH▀оХI6  КE▀дH▀уH▀оХm5  E▀Т┘ю▀ьuE┴w4▀D$pA┴G8▀цL█\$@I▀[8I▀k@I▀sHI▀ЦA_A^A]A\_цлллллллл@SH┐Л H▀ы3и8▀%  ┬▀т  t╡H▀кХu8  КH▀┐`  ┴┬  П	$H▀┐`  г─      ─П	$H▀кХЩ'  H▀кХ╔,  L█D$0╡H▀кХB4  D╥D$0╡fA│х ─H▀кХ╛3  L█D$0╡H▀кХ4  E3ю╡H▀кХ░3  H▀кХL7  H┐д [цллллллH┐Л(E3юH█$E█HH▀│`  B▀└    I┐ю┴H┐бI┐ИuА▀$H│   ▀D$H│═  ▀D$H│≤  ▀D$H│╟  ▀D$H│Ю  2юH┐д(цлллллллллH▀дH┴XH┴hH┴pH┴x ATH┐Л H▀ыH│аh  L▀Б3Ъ3ЖЪ░J  ┬┐p  H▀┐ь  E3юКdL9═╦   H▀пuRг─▄    ю┐┐Ь  ЪM┘юH▀uH┘иH┴▀ь  uH!▀Ю  КH┘иI┴uL┴┐Ю  H┘ЪH▀ uH▀ЗКH┴H▀РКL▀юH▀ H┘юu≈┼⌠p  H█▀h  Ъ
J  H┘ЪtH┐& H▀▀  E3юH▀вЪI  H▀\$0H▀l$8H▀t$@H▀|$HH┐д A\цлллллллH┴\$WH┐Л ┐zH▀Ыu0H│аX  Ъ╓I  H█▐X  ф┤т   ┼п┬┤`  ф┤░   Ъ┴I  H▀\$0H┐д _цллллллH┴\$H┴t$WH┐Л H▀ыH│аx  ЪQI  H█▀x  г┐<     ┼п┬┐─  Ъ:I  3Ъ╧(   ЪмG  ┐╩   t┐г┐ЪdrДH█▀x  ЪI  ┐ё   ┐ё<   H█▀x  ┼п┬┐─  ЪЛH  H▀\$0H▀t$83юH┐д _цллллллH┴\$WH┐Л H▀ыH│аX  Ъ╡H  H█▀X  г┐<     ┼п┬┐`  Ъ⌡H  H▀\$03юH┐д _цллллллH┴\$H┴t$WH┐Л H▀ЫH│аX  H▀зЪ^H  ─©т   H█▐X  ┬┤`  ┼пuЪHH  ╦ юК6Ъ;H  ▀C┘юt┐Хt┐Ьt╦╩  юКH▀сH▀оХТЬЪЪКH▀сH▀оХGСЪЪH▀\$0H▀t$8H┐д _цлллллллб  лллллллллH▀дH┴XH┴hH┴pH┴x ATAUAVH┐Л0D▀iM▀АM▀ПD;Йw	A┐! И╕   ▀A(H▀Y 3Ж█,И└   E┘М└┬   ЖC
tH▀SК"E3и3рH▀кE█AгD$(   ┐d$  ЪVG  H▀пH┘р▀{(tP;Щv<+Щ▀мHяA;ЩAGЩ█7A;$vA▀<$+ЧD▀гI▀нD+О▀ОХBA  ВA;4$sLУ3МК+ОH▀H┘ш┘sЪЪЪК3ЖA┴4$H▀\$PH▀l$XH▀t$`H▀|$hH┐д0A^A]A\цллллллH┴T$L┴D$L┴L$ SVWH┐Л H▀Я3Ъ3ш3иЖu/╥F╗u'f9w"f=ЧЪwH9Nu
f9uf┘юuH▀N╥ЬHяОК╩  ю┘шx,L▀бL█L$PH▀в3шЪQF  ┘юxH≤H;гvH▀г╩  ─fюf┴▀цH┐д _^[цллллллH┴\$WH┐Л H▀ЗЪuE  3шH▀H;кu╩н юК8≥т  t8≥░  u╩с ю3рH▀о┴_0ЪыE  ▀цH▀\$0H┐д _цллллллллH┴\$WH┐Л@H▀ ╦   H▀ЗЪE  H▀H┘рu╩н юКB─╨т   t4─╨░   t+H▀Op▀CD▀SL▀K D▀C┴D$0H┴L$(H▀оD┴T$ Х(   К╩с ю3рH▀о┴_0ЪKE  ▀цH▀\$PH┐д@_цллллллH▀дH┴XH┴hVWATAUAVH┐Л@H█h╦c " E3ЖD;юH▀РL▀А©   ┤╨  └T  A│Х3 " └  D+г└╖  D+г└█  A┐Х└2  D+г└с   D+г└²   A┐ХtWD;г┘   M┘иt@9╪$░   r7A╥A╥I=   ┴L$0┐Ё  D╥а┼пH▀нХМ,  D╤ьD┴°$─   И°  3М3ЪИ⌠  M┘иtР┐╪$░   rХA╥┐Ь sъD!╢$─   L█└$─   ┼пH▀нХ!-  └юtа©   ИS  H▀йХс!  H█▌  3рD╤ьA╦п  D┴°$─   Х;=  И&  M┘иt┘┐╪$░   ┌wЪЪЪA▀AE▀┴D$0J█H=   ┐П  H▀▌  L█L$03р┴|$ Ъ C  г└$─      Ип  M┘и└+ЪЪЪ9╪$░   ┌ЪЪЪE▀J█H=   ┐ЪЪЪH▀▌  D!╢$─   L█▄$─   3р┴|$ ЪлB  И  H█╙  ©п  Иn  M┘и└иЧЪЪ┐╪$░   ┌╩ЧЪЪE▀▀▌h  A▀QI█@┴T$0H;а┐1  H▀├`  г└$─      A┴ ПD	4$И  M┘и└tЧЪЪ9╪$░   ┌gЧЪЪA▀▀▌h  H█BH;а┐QЧЪЪH▀├`  ▀┴└$─   Ив  M┘и└2ЧЪЪ┐╪$░   p┌$ЧЪЪH▀■$≤   H▀нХp3  └юD╤ьD┴°$─   └ ЧЪЪM┘ДtE!t$03рI▀лIгD$8p   ЪNB  3юИх  A│Х┐ " └J  D+г└╠   A┐Хt|D+гt^D+гtGD+гt*D;гtA╬  юИu  ╤┌Э  3и┘ю■а┴▄$─   И"  H▀┌`  ▀┬  юИ─А╤аКуH▀┌`  ▀┬  аИКФH▀йХ4  D╤ь3юE┘ш■юИЭЧЪЪM┘и└:ЩЪЪ┐╪$░   ┌,ЩЪЪA┼L█└$─   H▀нХ╧8  И╟   M┘и└ЩЪЪ┐╪$░   ┌ЩЭЪЪE81H█┼X  ∙цЪ~A  ┬·  ┬├`  H▀├`  ▀┬─  ╦  х└ш┴▌  tхК│АОЪЪВH▀├`  ┴▌  ▀я┴┬─  ПD	4$┼√`  H█▌X  Ъ%A  И@ЩЪЪH▀йХ|  H▀нХ$"  H▀нХ░  D!╢$─   M┘Дt▀гI┴D$8;╪$═   wH┘Мt┘ЪtH▀▄$≤   D▀гH▀уХъ:  КA╬  юM┘Дt3рI▀лE┴t$0Ъ┌@  A▀фH▀\$pH▀l$xH┐д@A^A]A\_^цллллллллL▀эI┴[WH│Лp  H▀P  H3дH┴└$`  f┐d$  f┐d$0 I█┐hЪЪЪH┴D$(H▀ыI█┐ХЧЪЪI█▀ЧЪЪ3рA╦Ю   H┴D$8fгD$"─ fгD$2─ Х69  H█оЫЪЪ3рH█╪$─   ╧   D█B8СH╚H█ЗЪЪH█L$@H┴└$П   Х 9  D▀-S  H┐d$h H┐d$p H█└$─   L█╝=  H█в=  H█L$ H┴D$XфD$@─фD$AfгD$B8 гD$`   Х╥ЬЪЪ┘ю┬■   ▀уR  L█╙=  H█⌠=  D▀х┐юH█L$0┴╤R  Х┘ЬЪЪ┘юxfH▀▀  H█D$ L█╕R  H┴D$HH█D$0L██R  H█T$@H┴D$PЪ%>  ┘юu.H▀zR  H┴┐   H▀dR  H┴┐ю  H▀VR  Ъ@>  H┴3юH▀▄$`  H3лХц6  H▀°$┬  H│дp  _цллллллH┴\$H┴l$H┴t$ WH│Л░   3МI▀ьH▀Ыг│   э  г│   ─√≤ ф│  @┬╘Э  @┬╘  @┬╘%  @┬╘░  @┬╘т  @┬╘└  Х╚  H▀▐  H┴╞X  H┴╞x  H┴╞h  H▀[L█▐э  E3ю3ргD$    Ъ│=  ┐Ь@┌k  ╥▐э  ╥≈ч  ▀ааЮбf│Ыi┴┤ь  ┘E  f│ЗH ┘:  H;щ└1  9kD▀еvlH█K╤QЭ┐Йt8┐Йt ┐ЗuGЖAЧuAH▀H┴┤X  ▀A┴┤h  К,▀┴┤l  ▀A┴┤p  КЖAЧtH▀H┴┤@  ▀A┴┤P  A┐юH┐аD;Cr≤9╞h  └╠   9╞l  └╔   H▀▐  ╬   L█▄$═   █^3р┴t$ D▀цЪ▄<  D╥°$═   A┼ц$<t,H▀▐  fA┐кL█▄$═   D▀ц3рfD┴°$═   ┴t$ ЪF<  D▀▐h  L▀┤X  H▀≈  H█▐`  Ъ4<  ;еt6H▀▐  A╧  `A╦   ▀пЪЕ;  2юL█°$░   I▀[I▀k I▀s(I▀Ц_цH▀┤`  ┴╗  П	,$H▀┤`  г─      ─П	,$3рH█L$0D█B`Х└5  H▀▐  H█фЮЪЪH┴D$8H█FБЪЪL█▐(  H┴D$@H█wЮЪЪL█D$0H┴D$HH█зЮЪЪH▀вфD$0└фD$1fгD$2` H┴D$PЪ≈;  ;еt;H▀▐  A╧  `A╦   ▀пЪ;  D▀┤h  H▀≈`  H▀▐  ЪE;  ИЪЪЪ▀└$─   ф┤t  ;ф┴┤8  uH▀└$┬   H┴┤0  H▀оH┴╞Ю  H┴╞ь  Х  @:еu+H▀▐  ╨  юA╧  `A╦   Ъ≤:  H▀оХ$   И╕ЧЪЪH▀╪N  H┴=╣N  H┴╟И░ЧЪЪллллллл@SH┐Л H┘иH▀ыte─╧t   tH▀┴(  Ъ┬:  H▀кХ═  H▀кХ  H▀▀H  H┘иtЪ╤:  3рH█▀░  D█BpХ4  D▀┐h  H▀⌠`  H▀▀  ЪA:  ╟H┐д [цлллллллллL▀эSUVWH┐ЛXH▀│  A┐c I┐c  H▀ЫфD$8╘фD$9fгD$: I┴Cх┐d$H I█SI█KюЪы9  ┘ю┴└$─   ┘V  H█kJ  █h▀s3ю9t	┐;∙ю┐юL▀└$░   L█KПH█■$≤   H█▄$─   ┴D$ Ъ╦9  ┐╪$─    u┐;wGH▀└$≤   ▀H;Kr;KvК┐;w+┐╓$─    ▀K▀C┐Хt┐Хt
┐Хu┴>К	f┴>К┬>H┐ц(H┐М┘dЪЪЪL▀▄$░   L█└$┬   H█T$0H█▄$─   Ъ!9  9╛$─   uO┐╪$┬   uEH▀L$0Жu;╟Ъ8u8Au8Au8Au
8Au8At▀┴┤Н  ╥Aф┤Т  f┴┤Р  Кф┤Т   H▀▄$░   ┐╓$─    ╦ЧЪЪЪ!┤┬  !┤▄  Ъ⌠8  ▀└$─   H┐дX_^][цлллллллH┴\$H┴t$ WH┐Лp3рH▀ЫH█L$@D█B(ХЗ1  H▀▐  ┐d$D H┐d$P L█┤H  H█T$@фD$@┐фD$AfгD$B( гD$HЙ  Ъ┘7  ┘ю┘─  ▀┤▄  iюР  =ЪЪ ┴┤т  v
г┤т  ЪЪ ▀┤┬  L█▄$┬   E3ю█@▀┤т  аА▐▄  █■┬╗   H█└$─   ┴≈═  H▀▐  H┴D$ ЪП6  H▀▄$┬   ▀╢$└   H┘иH▀°$─   t┘ш┘и   я╞▄  я╞┬  ┐©▄   s
г┤▄      ┐©┬  @s
г┤┬  @   ▀┤▄  iюР  =ЪЪ ┴┤т  v
г┤т  ЪЪ ▀┤┬  L█▄$┬   E3ю█@▀┤т  аА▐▄  █■┬╗   H█└$─   ┴≈═  H▀▐  H┴D$ Ъ-6  H▀▄$┬   H▀└$─   H┘и▀╢$└   ▀ь└)  ┘ю└!  D▀┤═  3рХM0  L▀▄$┬   D▀цA┐ЮA╨   ┴÷≤  L┴▐░  A▀б┴╥°  A+юE┘юH█T$0DEюA█┴┤Ю  K█H┴┤ь  ▀▐▄  A█┬ьI█┬Lх▀кA▀б┐А+а┘иEх█┴┤п  ▀а▐т  IаыH┴┤х  ▀а█KLх┐АA█Bp+аВыL┴▄$┬   и#х█┴┤╟  ▀аIаH┴┤╗  H▀▐  3юH┴D$0f!D$6H┴D$8фD$0─фD$1fD┴T$2┬D$4фD$5гD$8iV2LЪ5  H┴GHВьюВп%   юК╦  юL█\$pI▀[ I▀s(I▀Ц_цллллллл@SH┐Л0L▀┴░  H▀ыM┘иt<▀│°  ▀▒═  E3ю┴D$D▀│≤  H▀┴  ┴D$@H▀D$@H┴D$ Ъc5  H┐ё░   ┐ё╟   H┐ё╗   ┐ёп   H┐ёх   ┐ёЮ   H┐ёь   H┐д0[цллллллллH┴\$H┴t$WH┐Л H┐╧ю   H▀ыtW3Ж9╠ackpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {}\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r\n                    )\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true)\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTruen a   % 1 ! s ! .   O b r a t i t e   s e   k o r i s n i k o j   p o d r ac i   i l i   d o b a v l j a u   u s l u g e .   PAn P o at a n s k o   s a n d u e   j e   s k o r o   p u n o .   I s p r a z n i t e   f a s c i k l u   s a   i z b r i s a n i m   s t a v k a m a   d a   b i s t e   n a p r a v i l i   v i ae   p r o s t o r a .   s U r e a j   n e   p o d r ~a v a   b e z b e d n o s n e   p o s t a v k e   p o t r e b n e   z a   s e r v e r .   O b r a t i t e   s e   k o r i s n i k o j   p o d r ac i   i l i   d o b a v l j a u   u s l u g e .   ▓ D o al o   j e   d o   p r o b l e m a   s a   s i n h r o n i z a c i j o m   i n f o r m a c i j a .   M o ~d a   e   s e r v e r   o d   v a s   z a t r a ~i t i   d a   i z a b e r e t e   ai f r o v a n u   ( S S L )   v e z u   u   p o s t a v k a m a   o v o g   n a l o g a .    e - p o at a   i   n a l o z i   Ю M o ~d a   j e   p o t r e b n o   d a   p o n e t e   d a   k o r i s t i t e   p o at u ,   k o n t a k t e   i   k a l e n d a r   n a   r a u n a r u   d a   b i s t e   m o g l i   d a   s i n h r o n i z u j e t e   o v e   i n f o r m a c i j e   s a   u r e a j e m .   A k o   o v a j   p r o b l e m   p o t r a j e ,   o b r a t i t e   s e   k o r i s n i k o j   p o d r ac i   i l i   d o b a v l j a u   u s l u g e .   , K o r i s n i k   n e m a   o v l a ae n j e   z a   s i n h r o n i z a c i j u .   и N e   m o g u   d a   d o d a m   o v a j   n a l o g   n a   u r e a j   j e r   s t e   g a   v e   p o d e s i l i   n a   m a k s i m a l n o   d o z v o l j e n o m   b r o j u   u r e a j a .  
  
 M o ~e t e   d a   p o k u aa t e   d a   u k l o n i t e   u r e a j e   s a   n a l o g a   n a   v e b u   i l i   d a   k o n t a k t i r a t e   p o d r ak u   z a   n a l o g .     q % 1 ! s !   v a m   n e   d o z v o l j a v a   d a   o d g o v o r i t e   n a   o v u   p o r u k u .   P o k u aa j t e   p o n o v o   k a s n i j e   i l i   p o aa l j i t e   o d g o v o r   s a   r a u n a r a .   w D o al o   j e   d o   p r o b l e m a   n a   s e r v e r u   % 1 ! s !   u   t o k u   s l a n j a   o v e   p o r u k e .   P o k u aa j t e   p o n o v o   k a s n i j e   i l i   j e   p o aa l j i t e   s a   r a u n a r a .   f D o al o   j e   d o   p r o b l e m a   s a   s l a n j e m   o d g o v o r a .   P o k u aa j t e   p o n o v o   k a s n i j e   i l i   p o aa l j i t e   o d g o v o r   s a   r a u n a r a .       { N e   m o g u   d a   p r o n a e m   o v u   s t a v k u   u   p o at a n s k o m   s a n d u e t u .   S i n h r o n i z u j t e   n a l o g   d a   b i s t e   s e   u v e r i l i   d a   s t a v k a   j o a  u v e k   p o s t o j i .                 ■ N e   m o ~e t e   d a   aa l j e t e   p o at u   s a   o v o g   n a l o g a .   I z g l e d a   d a   j e   d o al o   d o   p r o b l e m a   s a   s e r v e r o m .   V i ae   i n f o r m a c i j a   z a t r a ~i t e   o d   k o r i s n i k e   p o d r ak e   z a   s e r v e r .   ■ N e   m o ~e t e   d a   aa l j e t e   p o at u   s a   o v o g   n a l o g a .   I z g l e d a   d a   j e   d o al o   d o   p r o b l e m a   s a   s e r v e r o m .   V i ae   i n f o r m a c i j a   z a t r a ~i t e   o d   k o r i s n i k e   p o d r ak e   z a   s e r v e r .   m I z g l e d a   d a   o v e   a d r e s e   e - p o at e   n i s u   u   f u n k c i j i .   P r o v e r i t e   d a   l i   s u   a d r e s e   i s p r a v n e ,   a   z a t i m   p o k u aa j t e   p o n o v o .   ⌡ N e   m o ~e t e   d a   o d g o v a r a t e   n a   p o r u k e   s a   o v o g   n a l o g a .   I z g l e d a   d a   j e   d o al o   d o   p r o b l e m a   s a   s e r v e r o m .   V i ae   i n f o r m a c i j a   z a t r a ~i t e   o d   k o r i s n i k e   p o d r ak e   z a   s e r v e r .   m I z